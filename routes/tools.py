import os
import zipfile
import shutil # Import shutil for directory operations
from datetime import datetime
from flask import Blueprint, render_template, request, redirect, url_for, flash, send_file
from src.system import get_project_root, DATA_DIR, delete_all_temporary_files

tools_bp = Blueprint('tools', __name__, url_prefix='/tools')

@tools_bp.route('/backup_restore')
def backup_restore():
    """Renders the backup and restore page."""
    return render_template('tools/backup_restore.html')

@tools_bp.route('/backup_data', methods=['GET'])
def backup_data():
    """Handles the backup of all league data."""
    try:
        root_path = get_project_root()
        data_path = os.path.join(root_path, DATA_DIR)
        
        if not os.path.exists(data_path):
            flash("No data directory found to backup.", "danger")
            return redirect(url_for('tools.backup_restore'))

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"slamsim_backup_{timestamp}" # No .zip extension here for make_archive
        
        # Create the zip archive
        # shutil.make_archive(base_name, format, root_dir, base_dir)
        # base_name: The name of the archive file to create, including the path, but without the .zip extension.
        # format: The archive format, e.g., 'zip'.
        # root_dir: The directory from which to start archiving.
        # base_dir: The directory that will be archived.
        archive_path = shutil.make_archive(
            os.path.join(root_path, backup_filename), # Archive will be created in root_path
            'zip',
            root_path, # Start archiving from the project root
            DATA_DIR   # Archive the 'data' directory relative to root_path
        )

        flash("League data backed up successfully!", "success")
        return send_file(archive_path, as_attachment=True, download_name=os.path.basename(archive_path))

    except Exception as e:
        flash(f"Error creating backup: {e}", "danger")
        return redirect(url_for('tools.backup_restore'))

@tools_bp.route('/restore_data', methods=['POST'])
def restore_data():
    """Handles the restoration of league data from a backup file."""
    if 'backup_file' not in request.files:
        flash('No file part', 'danger')
        return redirect(url_for('tools.backup_restore'))
    
    file = request.files['backup_file']
    if file.filename == '':
        flash('No selected file', 'danger')
        return redirect(url_for('tools.backup_restore'))

    if file and file.filename.endswith('.zip'):
        root_path = get_project_root()
        data_path = os.path.join(root_path, DATA_DIR)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        old_data_path = f"{data_path}_old_{timestamp}"
        temp_zip_path = os.path.join(root_path, f"temp_restore_{timestamp}.zip") # Unique temp name

        try:
            # 1. Save the uploaded zip file temporarily
            file.save(temp_zip_path)

            # 2. Rename existing data directory as a safeguard
            if os.path.exists(data_path):
                shutil.move(data_path, old_data_path)
                flash(f"Existing data moved to '{os.path.basename(old_data_path)}' as a safeguard.", "info")
            
            # 3. Create a new, empty data directory
            os.makedirs(data_path, exist_ok=True)
            
            # 4. Unzip the contents of the uploaded file into the new data directory
            with zipfile.ZipFile(temp_zip_path, 'r') as zip_ref:
                # Check if the zip contains a 'data/' directory at its root
                # If so, extract to root_path so 'data/' is created correctly
                namelist = zip_ref.namelist()
                if any(name.startswith(f'{DATA_DIR}/') for name in namelist):
                    zip_ref.extractall(root_path)
                else:
                    # Otherwise, extract directly into the new data_path
                    zip_ref.extractall(data_path)

            # 5. Clean up temporary files and old data directory
            os.remove(temp_zip_path)
            if os.path.exists(old_data_path):
                shutil.rmtree(old_data_path) # Remove the old data directory after successful restore
            
            # 6. Clear any temporary files generated by the application
            delete_all_temporary_files()

            flash('League data restored successfully!', 'success')
            return redirect(url_for('booker.dashboard'))

        except zipfile.BadZipFile:
            flash('Invalid backup file. Please upload a valid .zip file.', 'danger')
            # Attempt to revert if extraction failed due to bad zip
            if os.path.exists(data_path):
                shutil.rmtree(data_path) # Remove the incomplete new data dir
            if os.path.exists(old_data_path):
                shutil.move(old_data_path, data_path) # Restore old data
                flash("Attempted to restore previous data due to invalid backup file.", "info")
        except Exception as e:
            flash(f'Error restoring data: {e}. Please check the "{os.path.basename(old_data_path)}" directory for manual recovery.', 'danger')
            # If any other error, ensure old data is preserved and new (potentially corrupt) data is removed
            if os.path.exists(data_path):
                shutil.rmtree(data_path) # Remove the incomplete new data dir
            if os.path.exists(old_data_path) and not os.path.exists(data_path): # Only move back if data_path is truly gone
                shutil.move(old_data_path, data_path) # Restore old data
                flash("Attempted to restore previous data due to restoration error.", "info")
        finally:
            if os.path.exists(temp_zip_path):
                os.remove(temp_zip_path)
    else:
        flash('Invalid file type. Please upload a .zip file.', 'danger')
    
    return redirect(url_for('tools.backup_restore'))
