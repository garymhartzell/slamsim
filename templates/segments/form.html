{% extends "_base.html" %}

{% block title %}
    {% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}) for {{ event_slug }}{% else %}Create New Segment for {{ event_slug }}{% endif %}
{% endblock %}

{% block content %}
    <h1>{% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}){% else %}Create New Segment{% endif %} for {{ event_slug }}</h1>

    <form method="POST" action="{{ url_for('segments.create_segment', event_slug=event_slug) if not segment.get('position') else url_for('segments.edit_segment', event_slug=event_slug, position=original_position) }}">
        <div class="form-group">
            <label for="position">Position <span class="text-danger">*</span></label>
            <input type="number" class="form-control" id="position" name="position" value="{{ segment.get('position', '') }}" required min="1">
        </div>
        <div class="form-group">
            <label for="type">Type <span class="text-danger">*</span></label>
            <select class="form-control" id="type" name="type" required onchange="toggleMatchFields();">
                <option value="">--Select Type--</option>
                {% for seg_type in segment_type_options %}
                    <option value="{{ seg_type }}" {% if segment.get('type', '') == seg_type %}selected{% endif %}>{{ seg_type }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="form-group">
            <label for="header">Header</label>
            <input type="text" class="form-control" id="header" name="header" value="{{ segment.get('header', '') }}">
        </div>

        {# Participants Builder for Match segments #}
        <div id="match-specific-fields" style="display: none;">
            <h3>Match Participants Builder</h3>
            <div class="form-group">
                <label>Add Participant to Current Side:</label>
                <div class="input-group">
                    <select class="form-control" id="wrestler-select">
                        <option value="">--Select Wrestler--</option>
                        {% for wrestler in all_wrestlers %}
                            <option value="wrestler:{{ wrestler.Name }}">{{ wrestler.Name }}</option>
                        {% endfor %}
                    </select>
                    <button type="button" class="btn btn-info" onclick="addParticipantToCurrentSide('wrestler')">Add Wrestler</button>
                </div>
                <div class="input-group mt-2">
                    <select class="form-control" id="tagteam-select">
                        <option value="">--Select Tag Team--</option>
                        {% for team in all_tagteams %}
                            <option value="tagteam:{{ team.Name }}" data-members="{{ team.Members }}">{{ team.Name }}</option>
                        {% endfor %}
                    </select>
                    <button type="button" class="btn btn-info" onclick="addParticipantToCurrentSide('tagteam')">Add Tag Team</button>
                </div>
                <button type="button" class="btn btn-secondary mt-2" onclick="addNewSide()">Add VS. Side</button>
            </div>

            <div id="match-sides-container" class="mt-3">
                {# Dynamically generated sides and participants will go here #}
            </div>
            <p class="mt-3"><strong>Participants Display:</strong> <span id="current-participants-display"></span></p>
            <input type="hidden" id="participants_display_input" name="participants_display" value="{{ match_data.get('participants_display', '') }}">
            <input type="hidden" id="match_sides_json_input" name="match_sides_json" value="{{ match_data.get('sides', []) | tojson }}">

            <hr>
            <h4>Match Details</h4>
            <div class="form-group">
                <label for="match_result">Match Result</label>
                <input type="text" class="form-control" id="match_result" name="match_result" value="{{ match_data.get('match_result', '') }}">
            </div>
            <div class="form-group">
                <label for="match_time">Match Time (MM:SS)</label>
                <input type="text" class="form-control" id="match_time" name="match_time" value="{{ match_data.get('match_time', '') }}" pattern="^\d{2}:\d{2}$" placeholder="e.g., 05:30">
            </div>
            <div class="form-group">
                <label for="match_championship">Match Championship</label>
                <input type="text" class="form-control" id="match_championship" name="match_championship" value="{{ match_data.get('match_championship', '') }}">
            </div>
            <div class="form-group form-check">
                <input type="checkbox" class="form-check-input" id="match_hidden" name="match_hidden" {% if match_data.get('match_hidden', False) %}checked{% endif %}>
                <label class="form-check-label" for="match_hidden">Match Hidden</label>
            </div>
        </div>

        <div class="form-group">
            <label for="summary_text">Summary Text</label>
            <textarea class="form-control" id="summary_text" name="summary_text" rows="8">{{ summary_content | default('') }}</textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            {% if segment.get('position') %}Update Segment{% else %}Create Segment{% endif %}
        </button>
        <a href="{{ url_for('events.view_event', event_name=event_slug) }}" class="btn btn-secondary">Cancel</a>
    </form>

    <script>
        // Data from Flask
        const allWrestlers = {{ all_wrestlers | tojson }};
        const allTagTeams = {{ all_tagteams | tojson }};
        let currentSides = {{ match_data.sides | tojson }};
        let segmentType = document.getElementById('type').value;

        // Initialize with at least two sides if empty for a new match
        if (segmentType === 'Match' && currentSides.length === 0) {
            currentSides = [
                { members: [], tagteam: null },
                { members: [], tagteam: null }
            ];
        }

        function getTagTeamMembers(tagteamName) {
            const team = allTagTeams.find(t => t.Name === tagteamName);
            return team ? team.Members.split('|').map(m => m.trim()) : [];
        }

        function renderSides() {
            const container = document.getElementById('match-sides-container');
            container.innerHTML = '';
            
            if (currentSides.length === 0) {
                container.innerHTML = '<p>No sides added yet. Use "Add VS. Side" to start building your match.</p>';
                updateParticipantsDisplay();
                return;
            }

            currentSides.forEach((side, sideIndex) => {
                const sideDiv = document.createElement('div');
                sideDiv.className = 'card mb-3';
                sideDiv.draggable = true;
                sideDiv.ondragstart = (e) => drag(e, 'side', sideIndex);
                sideDiv.ondragover = (e) => allowDrop(e);
                sideDiv.ondrop = (e) => drop(e, 'side', sideIndex);

                let participantsHtml = side.members.map((member, memberIndex) => `
                    <li draggable="true" ondragstart="drag(event, 'member', ${sideIndex}, ${memberIndex})" ondragover="allowDrop(event)" ondrop="drop(event, 'member', ${sideIndex}, ${memberIndex})">
                        ${member}
                        <button type="button" class="btn btn-sm btn-danger ms-2" onclick="deleteParticipant(${sideIndex}, ${memberIndex})">X</button>
                    </li>
                `).join('');

                sideDiv.innerHTML = `
                    <div class="card-header bg-light d-flex justify-content-between align-items-center">
                        Side ${sideIndex + 1} ${side.tagteam ? '(' + side.tagteam + ')' : ''}
                        <div>
                            <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="setSideAsCurrent(${sideIndex})">Set as Current</button>
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteSide(${sideIndex})">Delete Side</button>
                        </div>
                    </div>
                    <ul class="list-group list-group-flush p-2">
                        ${participantsHtml || '<li class="list-group-item text-muted">No participants in this side.</li>'}
                    </ul>
                `;
                container.appendChild(sideDiv);
            });
            updateParticipantsDisplay();
            updateHiddenInputs();
        }

        function addParticipantToCurrentSide(type) {
            let selectElement;
            let participantName;
            let tagteamName = null;
            let membersToAdd = [];

            if (type === 'wrestler') {
                selectElement = document.getElementById('wrestler-select');
                participantName = selectElement.value.split(':')[1];
                if (!participantName) {
                    alert('Please select a wrestler.');
                    return;
                }
                membersToAdd.push(participantName);
            } else if (type === 'tagteam') {
                selectElement = document.getElementById('tagteam-select');
                tagteamName = selectElement.value.split(':')[1];
                if (!tagteamName) {
                    alert('Please select a tag team.');
                    return;
                }
                membersToAdd = getTagTeamMembers(tagteamName);
                if (membersToAdd.length === 0) {
                    alert(`Could not find members for tag team "${tagteamName}".`);
                    return;
                }
            }

            if (currentSides.length === 0) {
                currentSides.push({ members: [], tagteam: null });
            }

            const currentSideIndex = parseInt(document.body.dataset.currentSideIndex || '0');
            if (currentSideIndex >= currentSides.length) {
                // Should not happen if currentSides is initialized properly
                currentSides.push({ members: [], tagteam: null });
                document.body.dataset.currentSideIndex = currentSides.length - 1;
            }

            const targetSide = currentSides[currentSideIndex];
            
            // If adding a tag team, update the side's tagteam property
            if (type === 'tagteam') {
                targetSide.tagteam = tagteamName;
            }

            membersToAdd.forEach(member => {
                if (!targetSide.members.includes(member)) {
                    targetSide.members.push(member);
                }
            });
            
            renderSides();
            selectElement.value = ''; // Clear selection
        }

        function addNewSide() {
            currentSides.push({ members: [], tagteam: null });
            renderSides();
            // Set new side as current one
            document.body.dataset.currentSideIndex = currentSides.length - 1;
        }

        function setSideAsCurrent(sideIndex) {
            document.body.dataset.currentSideIndex = sideIndex;
            flashCurrentSide(sideIndex);
        }

        function flashCurrentSide(sideIndex) {
            const sides = document.querySelectorAll('#match-sides-container .card');
            sides.forEach((sideDiv, idx) => {
                sideDiv.classList.remove('border-primary', 'border-3');
                if (idx === sideIndex) {
                    sideDiv.classList.add('border-primary', 'border-3');
                }
            });
        }

        function deleteParticipant(sideIndex, memberIndex) {
            if (currentSides[sideIndex]) {
                currentSides[sideIndex].members.splice(memberIndex, 1);
                // If the tagteam property is set and all its members are removed, clear tagteam
                if (currentSides[sideIndex].tagteam) {
                    const tagTeamMembers = getTagTeamMembers(currentSides[sideIndex].tagteam);
                    if (tagTeamMembers.every(m => !currentSides[sideIndex].members.includes(m))) {
                        currentSides[sideIndex].tagteam = null;
                    }
                }
                renderSides();
            }
        }

        function deleteSide(sideIndex) {
            if (confirm('Are you sure you want to delete this side?')) {
                currentSides.splice(sideIndex, 1);
                if (currentSides.length === 0) {
                    document.body.dataset.currentSideIndex = '0'; // Reset current side
                } else if (parseInt(document.body.dataset.currentSideIndex) >= currentSides.length) {
                    document.body.dataset.currentSideIndex = (currentSides.length - 1).toString();
                }
                renderSides();
            }
        }

        function updateParticipantsDisplay() {
            const displayElement = document.getElementById('current-participants-display');
            const displayInput = document.getElementById('participants_display_input');

            let sideStrings = [];
            currentSides.forEach(side => {
                if (side.members.length > 0) {
                    if (side.tagteam) {
                        sideStrings.push(side.tagteam);
                    } else {
                        sideStrings.push(side.members.join(', '));
                    }
                }
            });
            const displayString = sideStrings.join(' vs ');
            displayElement.textContent = displayString;
            displayInput.value = displayString;
        }

        function updateHiddenInputs() {
            document.getElementById('match_sides_json_input').value = JSON.stringify(currentSides);
        }

        function toggleMatchFields() {
            segmentType = document.getElementById('type').value;
            const matchFieldsDiv = document.getElementById('match-specific-fields');
            if (segmentType === 'Match') {
                matchFieldsDiv.style.display = 'block';
                // Ensure initial state for match builder on switch
                if (currentSides.length === 0) {
                    currentSides = [
                        { members: [], tagteam: null },
                        { members: [], tagteam: null }
                    ];
                }
                renderSides();
                flashCurrentSide(parseInt(document.body.dataset.currentSideIndex || '0'));

            } else {
                matchFieldsDiv.style.display = 'none';
            }
        }

        // Drag and Drop functionality
        let dragged = null;
        let draggedType = null;
        let draggedSideIndex = null;
        let draggedMemberIndex = null;

        function drag(e, type, sideIndex, memberIndex = null) {
            dragged = e.target;
            draggedType = type;
            draggedSideIndex = sideIndex;
            draggedMemberIndex = memberIndex;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', dragged.innerHTML); // Required for Firefox
        }

        function allowDrop(e) {
            e.preventDefault(); // Allows drop
            e.dataTransfer.dropEffect = 'move';
        }

        function drop(e, targetType, targetSideIndex, targetMemberIndex = null) {
            e.preventDefault();
            if (!dragged) return;

            if (draggedType === 'side' && targetType === 'side') {
                const movedSide = currentSides.splice(draggedSideIndex, 1)[0];
                currentSides.splice(targetSideIndex, 0, movedSide);
            } else if (draggedType === 'member' && targetType === 'member' && draggedSideIndex === targetSideIndex) {
                // Reorder within the same side
                const movedMember = currentSides[draggedSideIndex].members.splice(draggedMemberIndex, 1)[0];
                currentSides[targetSideIndex].members.splice(targetMemberIndex, 0, movedMember);
            } else if (draggedType === 'member' && targetType === 'side') {
                // Move member to a different side (or empty spot in same side)
                const movedMember = currentSides[draggedSideIndex].members.splice(draggedMemberIndex, 1)[0];
                currentSides[targetSideIndex].members.splice(targetMemberIndex === null ? currentSides[targetSideIndex].members.length : targetMemberIndex, 0, movedMember);

                // If moving a member out of a tagteam's side, and it was the last member of that tagteam in that side, clear tagteam from source side
                if (currentSides[draggedSideIndex].tagteam) {
                    const tagTeamMembers = getTagTeamMembers(currentSides[draggedSideIndex].tagteam);
                    if (tagTeamMembers.every(m => !currentSides[draggedSideIndex].members.includes(m))) {
                        currentSides[draggedSideIndex].tagteam = null;
                    }
                }
            } else {
                return; // Invalid drag/drop
            }

            dragged = null;
            renderSides();
        }

        // Call on page load to set initial visibility and render existing participants
        document.addEventListener('DOMContentLoaded', () => {
            document.body.dataset.currentSideIndex = '0'; // Default to first side
            toggleMatchFields();
            if (segmentType === 'Match' && currentSides.length > 0) {
                 flashCurrentSide(parseInt(document.body.dataset.currentSideIndex));
            }
        });
    </script>
{% endblock %}
