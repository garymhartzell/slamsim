{% extends "_base.html" %}

{% block title %}
    {% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}) for {{ event_slug }}{% else %}Create New Segment for {{ event_slug }}{% endif %}
{% endblock %}

{% block content %}
<div class="header-bar">
    <h2>{% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}){% else %}Create New Segment{% endif %} for {{ event_slug }}</h2>
    <div class="action-buttons">
        <a href="{{ url_for('events.edit_event', event_name=event_slug) }}">Back to Event</a>
    </div>
</div>

<form id="segment-form" class="wide-form" method="POST" action="{{ url_for('segments.create_segment', event_slug=event_slug) if not segment.get('position') else url_for('segments.edit_segment', event_slug=event_slug, position=original_position) }}">
    <fieldset class="form-section">
        <legend</h3>Segment Details</h3></legend>
        <div class="form-row">
            <div class="form-group">
                <label for="position">Position <span class="required">*</span></label>
                <input type="number" id="position" name="position" value="{{ segment.get('position', '') }}" required min="1">
            </div>
            <div class="form-group">
                <label for="type">Type <span class="required">*</span></label>
                <select id="type" name="type" required onchange="toggleMatchFields();">
                    <option value="">--Select Type--</option>
                    {% for seg_type in segment_type_options %}
                        <option value="{{ seg_type }}" {% if segment.get('type', '') == seg_type %}selected{% endif %}>{{ seg_type }}</option>
                    {% endfor %}
                </select>
            </div>
        </div>
        <div class="form-group">
            <label for="header">Header</label>
            <input type="text" id="header" name="header" value="{{ segment.get('header', '') }}">
            <small>Leave blank for matches to auto-generate (e.g., 'Singles Match').</small>
        </div>
    </fieldset>

    <div id="match-specific-fields" style="display: none;">
        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Participants Builder</h3></legend>
            <div class="form-group">
                <label for="participant-select">Add Participant to Current Side:</label>
                <div class="participant-adder">
                    <select id="participant-select">
                        <option value="">-- Select Participant --</option>
                        <optgroup label="Wrestlers">
                            {% for wrestler in all_wrestlers %}
                                <option value="wrestler:{{ wrestler.Name }}">{{ wrestler.Name }}</option>
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Tag Teams">
                             {% for team in all_tagteams %}
                                <option value="tagteam:{{ team.Name }}" data-members="{{ team.Members }}">{{ team.Name }}</option>
                            {% endfor %}
                        </optgroup>
                    </select>
                    <button type="button" class="btn btn-secondary" onclick="addParticipantToCurrentSide()">Add Participant</button>
                </div>
                <button type="button" class="btn btn-info" onclick="addNewSide()">Add VS. Side</button>
            </div>
            <div id="match-sides-container"></div>
            <p><h4>Participants Display:</h4> <span id="current-participants-display"></span></p>
            <input type="hidden" id="participants_display_input" name="participants_display" value="{{ match_data.get('participants_display', '') }}">
            <input type="hidden" id="match_sides_json_input" name="match_sides_json" value="{{ match_data.get('sides', []) | tojson | safe }}">
            <input type="hidden" id="match_results_json_input" name="match_results_json" value="{{ {'winning_side_index': match_data.winning_side_index, 'individual_results': match_data.individual_results, 'team_results': match_data.team_results, 'sync_teams_to_individuals': match_data.sync_teams_to_individuals} | tojson | safe }}">
        </fieldset>
        
        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Details</h3></legend>
            <div class="form-group">
                <label for="match_championship">Championship on the line</label>
                <select id="match_championship" name="match_championship" onchange="updateChampionDisplay()">
                    <option value="">-- None --</option>
                    {% for belt in all_belts %}
                        {% if belt.Status == 'Active' %}
                            <option value="{{ belt.Name }}" {% if match_data.get('match_championship') == belt.Name %}selected{% endif %}>
                                {{ belt.Name }}
                            </option>
                        {% endif %}
                    {% endfor %}
                </select>
                <p id="current-champion-display" class="form-static-text"></p>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="match_time">Match Time (MM:SS)</label>
                    <input type="text" id="match_time" name="match_time" value="{{ match_data.get('match_time', '') }}" pattern="^\d{1,2}:\d{2}$" placeholder="e.g., 05:30">
                </div>
                 <div class="form-group">
                    <input type="hidden" name="match_class" id="match_class_input" value="{{ match_data.get('match_class', '') }}">
                </div>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_from_card" name="hide_from_card_checkbox" {% if match_data.get('match_visibility', {}).get('hide_from_card', False) %}checked{% endif %}>
                <label for="hide_from_card">Match hidden from card</label>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_summary" name="hide_summary_checkbox" {% if match_data.get('match_visibility', {}).get('hide_summary', False) %}checked{% endif %}>
                <label for="hide_summary">Match summary hidden from event summary</label>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_result" name="hide_result_checkbox" {% if match_data.get('match_visibility', {}).get('hide_result', False) %}checked{% endif %}>
                <label for="hide_result">Match result hidden from card</label>
            </div>
            <input type="hidden" id="match_visibility_json_input" name="match_visibility_json" value="{{ match_data.get('match_visibility', {}) | tojson | safe }}">
        </fieldset>

        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Results</h3></legend>

            <!-- Overall match result -->
            <div class="form-group">
                <label for="match_result_overall">Overall Match Result</label>
                <select id="match_result_overall" name="match_result" class="form-control"></select>
                <small class="text-muted">Choose the overall outcome. Weâ€™ll generate the display string later.</small>
            </div>

            <!-- Winner method (only shown if match_result is a win) -->
            <div class="form-group" id="winner-method-group" style="display: none;">
                <label for="winner_method">Winning Method</label>
                <select id="winner_method" name="winner_method" class="form-control">
                    <option value="">-- Select Method --</option>
                    {% for method in winner_method_options %}
                        <option value="{{ method }}" {% if match_data.get('winner_method','') == method %}selected{% endif %}>{{ method|capitalize }}</option>
                    {% endfor %}
                </select>
                <small class="text-muted">Only required if the match has a winner.</small>
            </div>

            <!-- Note: The explicit "Winning Side" dropdown has been removed.
                 winning_side_index is now derived from the overall result. -->
            
            <div class="form-group mt-3">
                <label for="match_result_display">Match Result Display String</label>
                <textarea id="match_result_display" name="match_result_display" class="form-control" rows="3">{{ match_data.get('match_result_display', '') }}</textarea>
                <small class="text-muted">This string is auto-generated but can be manually edited.</small>
            </div>

            <div id="individual-results-container" class="results-container mt-3"></div>
            <div id="team-results-container" class="results-container"></div>
            <div class="form-group mt-2">
                <input type="checkbox" id="sync_teams_to_individuals" name="sync_teams_to_individuals" onchange="updateSyncToggle(this)" {% if match_data.get('sync_teams_to_individuals', True) %}checked{% endif %}>
                <label for="sync_teams_to_individuals">Sync Team Results to Individual Members</label>
            </div>
        </fieldset>
    </div>

    <fieldset class="form-section">
        <legend><h3>Summary</h3></legend>
        <div class="form-group">
            <label for="summary_text">Summary Text</label>
            <textarea id="summary_text" name="summary_text" rows="8">{{ summary_content | default('') }}</textarea>
        </div>
    </fieldset>

    <div class="action-buttons form-actions">
        <button type="submit" class="btn btn-primary">
            {% if segment.get('position') %}Update Segment{% else %}Create Segment{% endif %}
        </button>
        <a href="{{ url_for('events.edit_event', event_name=event_slug) }}" class="btn btn-secondary">Cancel</a>
    </div>
</form>

<script>
    // --- FULL JAVASCRIPT BLOCK ---
    const allWrestlers = {{ all_wrestlers | tojson | safe }};
    const allTagTeams = {{ all_tagteams | tojson | safe }};
    const allBelts = {{ all_belts | tojson | safe }};
    // Used for per-individual/team result dropdowns
    const matchResultOptions = {{ match_result_options | tojson | safe }};
    const winnerMethodOptions = {{ winner_method_options | tojson | safe }};
    let matchDataFromServer = {{ match_data | tojson | safe }};
    
    let currentSides = matchDataFromServer.sides || [];
    let currentMatchResults = {
        winning_side_index: matchDataFromServer.winning_side_index !== undefined ? matchDataFromServer.winning_side_index : -1,
        individual_results: matchDataFromServer.individual_results || {},
        team_results: matchDataFromServer.team_results || {},
        sync_teams_to_individuals: matchDataFromServer.sync_teams_to_individuals !== undefined ? matchDataFromServer.sync_teams_to_individuals : true,
    };
    // Overall result string + winner method
    let overallMatchResult = matchDataFromServer.match_result || "";
    let winnerMethod = matchDataFromServer.winner_method || "";

    document.addEventListener('DOMContentLoaded', () => {
        document.body.dataset.currentSideIndex = '0';
        toggleMatchFields();
        updateChampionDisplay();
        if (document.getElementById('type').value === 'Match') {
           renderSides();
        }
    });

    function toggleMatchFields() {
        const segmentType = document.getElementById('type').value;
        const matchFieldsDiv = document.getElementById('match-specific-fields');
        if (segmentType === 'Match') {
            matchFieldsDiv.style.display = 'block';
            if (currentSides.length === 0) {
                currentSides = [[], []];
            }
        } else {
            matchFieldsDiv.style.display = 'none';
        }
    }

    function updateChampionDisplay() {
        const select = document.getElementById('match_championship');
        const display = document.getElementById('current-champion-display');
        const selectedBeltName = select.value;
        if (!selectedBeltName) {
            display.textContent = ''; return;
        }
        const selectedBelt = allBelts.find(belt => belt.Name === selectedBeltName);
        if (selectedBelt) {
            display.textContent = `Current Champion: ${selectedBelt.Current_Holder || 'Vacant'}`;
        } else {
            display.textContent = '';
        }
    }

    function _get_all_wrestlers_involved_js(sides) {
        const wrestlers = new Set();
        sides.forEach(side => side.forEach(p => wrestlers.add(p)));
        return Array.from(wrestlers);
    }

    function _get_all_tag_teams_involved_js(sides, all_tagteams_data) {
        const teams = new Set();
        const team_member_sets = {};
        all_tagteams_data.forEach(t => {
            if (t.Name && t.Members) team_member_sets[t.Name] = new Set(t.Members.split('|'));
        });
        sides.forEach(side => {
            const side_members_set = new Set(side);
            for (const team_name in team_member_sets) {
                const members_set = team_member_sets[team_name];
                if ([...members_set].every(member => side_members_set.has(member)) && members_set.size > 1) {
                    teams.add(team_name);
                }
            }
        });
        return Array.from(teams);
    }

    function renderSides() {
        const container = document.getElementById('match-sides-container');
        container.innerHTML = '';
        currentSides.forEach((side, sideIndex) => {
            const sideDiv = document.createElement('div');
            sideDiv.className = 'card mb-3';
            let participantsHtml = side.map((member, memberIndex) => `
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <span>${member}</span>
                    <button type="button" class="btn btn-sm btn-danger" onclick="deleteParticipant(${sideIndex}, ${memberIndex})">X</button>
                </li>`).join('');
            sideDiv.innerHTML = `
                <div class="card-header bg-light d-flex justify-content-between align-items-center">
                    Side ${sideIndex + 1}
                    <div>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="setSideAsCurrent(${sideIndex})">Set as Current</button>
                        <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteSide(${sideIndex})">Delete Side</button>
                    </div>
                </div>
                <ul class="list-group list-group-flush p-2">${participantsHtml || '<li class="list-group-item text-muted">No participants.</li>'}</ul>`;
            container.appendChild(sideDiv);
        });
        flashCurrentSide(parseInt(document.body.dataset.currentSideIndex || '0'));
        updateParticipantsDisplay();
        renderResults();
    }

    function renderResults() {
        // Overall match_result dropdown
        const overallSelect = document.getElementById('match_result_overall');
        const overallOptions = [];

        // Per-side win options
        currentSides.forEach((side, index) => {
            const names = side.join(', ');
            overallOptions.push(`Side ${index + 1} (${names}) wins`);
        });

        // Draw/No contest options
        overallOptions.push(
            "Draw (Time limit)",
            "Draw (Double disqualification)",
            "Draw (Double count out)",
            "No contest"
        );

        // Populate select
        overallSelect.innerHTML = '';
        // Default blank
        const blank = document.createElement('option');
        blank.value = '';
        blank.textContent = '-- Select Overall Result --';
        overallSelect.appendChild(blank);

        overallOptions.forEach(opt => {
            const o = document.createElement('option');
            o.value = opt;
            o.textContent = opt;
            overallSelect.appendChild(o);
        });

        // Preserve previously selected value if still valid
        if (overallMatchResult && overallOptions.includes(overallMatchResult)) {
            overallSelect.value = overallMatchResult;
        } else {
            overallSelect.value = '';
        }

        overallSelect.addEventListener('change', (e) => {
            overallMatchResult = e.target.value;
            deriveWinningSideFromOverall();
            toggleWinnerMethodVisibility();
            updateHiddenInputs();
        });

        // Winner method visibility + prefill
        toggleWinnerMethodVisibility();
        const winnerMethodSelect = document.getElementById('winner_method');
        if (winnerMethod && winnerMethodOptions.includes(winnerMethod)) {
            winnerMethodSelect.value = winnerMethod;
        }

        // Individual / Team results
        const allWrestlersInMatch = _get_all_wrestlers_involved_js(currentSides);
        const allTeamsInMatch = _get_all_tag_teams_involved_js(currentSides, allTagTeams);
        const indContainer = document.getElementById('individual-results-container');
        const teamContainer = document.getElementById('team-results-container');
        indContainer.innerHTML = '<h4>Individual Results</h4>';
        teamContainer.innerHTML = '<h4>Team Results</h4>';
        
        allWrestlersInMatch.forEach(wrestler => {
            const result = currentMatchResults.individual_results[wrestler] || 'No Contest';
            indContainer.innerHTML += `
                <div class="form-group row align-items-center mb-1">
                    <label class="col-sm-4 col-form-label text-truncate">${wrestler}</label>
                    <div class="col-sm-8">
                        <select class="form-control form-control-sm" onchange="updateIndividualResult('${wrestler}', this.value)">
                            ${matchResultOptions.map(option => `<option value="${option}" ${result === option ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
        });
        if (allWrestlersInMatch.length === 0) indContainer.innerHTML += '<p class="text-muted">No wrestlers in match.</p>';

        allTeamsInMatch.forEach(teamName => {
            const result = currentMatchResults.team_results[teamName] || 'No Contest';
            teamContainer.innerHTML += `
                <div class="form-group row align-items-center mb-1">
                    <label class="col-sm-4 col-form-label text-truncate">${teamName}</label>
                    <div class="col-sm-8">
                        <select class="form-control form-control-sm" onchange="updateTeamResult('${teamName}', this.value)">
                            ${matchResultOptions.map(option => `<option value="${option}" ${result === option ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
        });
        if (allTeamsInMatch.length === 0) teamContainer.innerHTML += '<p class="text-muted">No tag teams in match.</p>';

        // Derive winning side initially (on load)
        deriveWinningSideFromOverall();
        updateHiddenInputs();
    }

    function deriveWinningSideFromOverall() {
        // If overall result is "Side N (...) wins", set winning_side_index = N-1; else -1
        const m = /^Side\s+(\d+)\s*\(/i.exec(overallMatchResult || '');
        if (m) {
            const n = parseInt(m[1], 10);
            if (!isNaN(n) && n >= 1 && n <= currentSides.length) {
                currentMatchResults.winning_side_index = n - 1;
                return;
            }
        }
        currentMatchResults.winning_side_index = -1;
    }

    function toggleWinnerMethodVisibility() {
        const group = document.getElementById('winner-method-group');
        if (overallMatchResult && overallMatchResult.toLowerCase().includes('wins')) {
            group.style.display = 'block';
        } else {
            group.style.display = 'none';
            document.getElementById('winner_method').value = '';
            winnerMethod = '';
        }
    }

    function addParticipantToCurrentSide() {
        const selectElement = document.getElementById('participant-select');
        const selectedValue = selectElement.value;
        if (!selectedValue) return;
        const [type, name] = selectedValue.split(':');
        let membersToAdd = [];
        if (type === 'wrestler') {
            membersToAdd.push(name);
        } else if (type === 'tagteam') {
            const team = allTagTeams.find(t => t.Name === name);
            if (team && team.Members) membersToAdd = team.Members.split('|');
        }
        const currentSideIndex = parseInt(document.body.dataset.currentSideIndex || '0');
        const targetSide = currentSides[currentSideIndex];
        if(targetSide){
            membersToAdd.forEach(member => { if (!targetSide.includes(member)) targetSide.push(member); });
            renderSides();
        }
        selectElement.value = '';
    }
    
    function addNewSide() {
        currentSides.push([]);
        setSideAsCurrent(currentSides.length - 1);
        renderSides();
    }
    
    function setSideAsCurrent(sideIndex) {
        document.body.dataset.currentSideIndex = sideIndex;
        flashCurrentSide(sideIndex);
    }
    
    function flashCurrentSide(sideIndex) {
        const sides = document.querySelectorAll('#match-sides-container .card');
        sides.forEach((div, idx) => div.classList.toggle('border-primary', idx === sideIndex));
    }

    function deleteParticipant(sideIndex, memberIndex) {
        currentSides[sideIndex]?.splice(memberIndex, 1);
        renderSides();
    }

    function deleteSide(sideIndex) {
        currentSides.splice(sideIndex, 1);
        setSideAsCurrent(Math.max(0, currentSides.length - 1));
        renderSides();
    }

    function updateParticipantsDisplay() {
        const displayElement = document.getElementById('current-participants-display');
        let sideStrings = currentSides.map(side => {
            if (side.length === 0) return '';
            const matchedTeams = _get_all_tag_teams_involved_js([side], allTagTeams);
            return matchedTeams.length > 0 ? matchedTeams.join(' & ') : side.join(', ');
        }).filter(s => s);
        displayElement.textContent = sideStrings.join(' vs ');
        document.getElementById('participants_display_input').value = displayElement.textContent;
    }

    function updateHiddenInputs() {
        // Keep winner_method synced
        const wmSelect = document.getElementById('winner_method');
        winnerMethod = wmSelect ? wmSelect.value : '';
        // Persist current results + derived winning side
        document.getElementById('match_sides_json_input').value = JSON.stringify(currentSides);
        document.getElementById('match_results_json_input').value = JSON.stringify(currentMatchResults);
        // overallMatchResult and winnerMethod are posted via named fields:
        //   name="match_result" on #match_result_overall
        //   name="winner_method" on #winner_method

        // New: Update match_visibility_json
        const matchVisibility = {
            hide_from_card: document.getElementById('hide_from_card').checked,
            hide_summary: document.getElementById('hide_summary').checked,
            hide_result: document.getElementById('hide_result').checked
        };
        document.getElementById('match_visibility_json_input').value = JSON.stringify(matchVisibility);
    }
    
    function updateIndividualResult(wrestler, result) { currentMatchResults.individual_results[wrestler] = result; updateHiddenInputs(); }
    function updateTeamResult(team, result) { currentMatchResults.team_results[team] = result; updateHiddenInputs(); }
    function updateSyncToggle(checkbox) { currentMatchResults.sync_teams_to_individuals = checkbox.checked; updateHiddenInputs(); }

    // JS version of _generate_side_display_string
    function _generateSideDisplayStringJS(side, allTagTeamsData) {
        const sideSet = new Set(side);
        const containedTeams = allTagTeamsData.filter(team => {
            const members = team.Members ? team.Members.split('|') : [];
            return members.length > 1 && members.every(member => sideSet.has(member));
        });
        
        const wrestlersInTeams = new Set();
        containedTeams.forEach(team => {
            (team.Members ? team.Members.split('|') : []).forEach(member => wrestlersInTeams.add(member));
        });
            
        const independentWrestlers = side.filter(w => !wrestlersInTeams.has(w));
        
        const parts = [];
        containedTeams.forEach(team => {
            const membersStr = team.Members ? team.Members.split('|').join(', ') : '';
            parts.push(`${team.Name} (${membersStr})`);
        });
        
        parts.push(...independentWrestlers);
        
        return parts.join(", ");
    }

    // JS version of generate_match_result_display_string
    function generateMatchResultDisplayStringJS() {
        const sides = currentSides;
        const winningSideIndex = currentMatchResults.winning_side_index;
        const matchResultOverall = overallMatchResult;
        const currentWinnerMethod = winnerMethod; // Use the current winnerMethod from JS state
        const matchChampionship = document.getElementById('match_championship').value;
        const matchTime = document.getElementById('match_time').value;

        const displayParts = [];
        
        if (winningSideIndex !== -1 && winningSideIndex >= 0 && winningSideIndex < sides.length) {
            // It's a win/loss scenario
            const winningSideParticipants = sides[winningSideIndex];
            const losingSidesParticipants = sides.filter((_, i) => i !== winningSideIndex);

            const winnerStr = _generateSideDisplayStringJS(winningSideParticipants, allTagTeams);
            const loserStr = losingSidesParticipants.map(side => _generateSideDisplayStringJS(side, allTagTeams)).filter(s => s).join(", ");

            displayParts.push(`${winnerStr} def. ${loserStr}`);

            if (currentWinnerMethod) {
                displayParts.push(`by ${currentWinnerMethod}`);
            }

            if (matchChampionship) {
                const belt = allBelts.find(b => b.Name === matchChampionship);
                if (belt) {
                    const currentHolder = belt.Current_Holder;
                    let isRetain = false;
                    if (currentHolder) {
                        if (belt.Holder_Type === 'Tag-Team') {
                            const winningSideMembers = new Set(winningSideParticipants);
                            const teamMembers = new Set(allTagTeams.find(t => t.Name === currentHolder)?.Members?.split('|') || []);
                            if (teamMembers.size > 0 && [...teamMembers].every(member => winningSideMembers.has(member))) {
                                isRetain = true;
                            }
                        } else { // Singles
                            if (winningSideParticipants.includes(currentHolder)) {
                                isRetain = true;
                            }
                        }
                    }
                    
                    if (isRetain) {
                        displayParts.push(`to retain the ${matchChampionship}`);
                    } else {
                        displayParts.push(`to win the ${matchChampionship}`);
                    }
                }
            }

        } else {
            // It's a draw or no contest
            if (sides.length > 0) {
                const participantDisplayForDraw = sides.map(side => _generateSideDisplayStringJS(side, allTagTeams)).filter(s => s).join(" vs ");
                if (matchResultOverall) {
                    // For draws/no contests, format as "ended in a [result]"
                    displayParts.push(`${participantDisplayForDraw} ended in a ${matchResultOverall.toLowerCase()}`);
                } else {
                    displayParts.push(participantDisplayForDraw); // Fallback if overall result is empty
                }
            } else if (matchResultOverall) {
                // If no sides but overall result exists (e.g., "No contest" without participants)
                displayParts.push(`Ended in a ${matchResultOverall.toLowerCase()}`);
            }
        }

        let finalString = displayParts.join(" ");

        if (matchTime) {
            finalString += ` (${matchTime})`;
        }
        return finalString;
    }

    function generateAndSetMatchResultDisplay() {
        matchResultDisplay = generateMatchResultDisplayStringJS();
        document.getElementById('match_result_display').value = matchResultDisplay;
    }

    // Modify renderSides to call generateAndSetMatchResultDisplay
    const originalRenderSides = renderSides;
    renderSides = function() {
        originalRenderSides();
        generateAndSetMatchResultDisplay();
    };

    // Modify updateChampionDisplay to call generateAndSetMatchResultDisplay
    const originalUpdateChampionDisplay = updateChampionDisplay;
    updateChampionDisplay = function() {
        originalUpdateChampionDisplay();
        generateAndSetMatchResultDisplay();
    };

    // Add event listener for match_time
    document.addEventListener('input', (event) => {
        if (event.target.id === 'match_time') {
            generateAndSetMatchResultDisplay();
        }
    });

    // Modify toggleWinnerMethodVisibility to update winnerMethod and call generateAndSetMatchResultDisplay
    const originalToggleWinnerMethodVisibility = toggleWinnerMethodVisibility;
    toggleWinnerMethodVisibility = function() {
        originalToggleWinnerMethodVisibility();
        // If hidden, winnerMethod is cleared, so we need to regenerate.
        // If shown, the select value might have changed, so we need to regenerate.
        winnerMethod = document.getElementById('winner_method').value; // Ensure winnerMethod is updated
        generateAndSetMatchResultDisplay();
    };

    // Add event listener for winner_method select
    document.addEventListener('change', (event) => {
        if (event.target.id === 'winner_method') {
            winnerMethod = event.target.value;
            generateAndSetMatchResultDisplay();
        }
    });

    // Update `renderResults` to include `generateAndSetMatchResultDisplay` call
    const originalRenderResults = renderResults;
    renderResults = function() {
        originalRenderResults(); // This will set up the overallSelect listener
        
        // Re-attach or ensure the overallSelect listener calls generateAndSetMatchResultDisplay
        const overallSelect = document.getElementById('match_result_overall');
        overallSelect.removeEventListener('change', handleOverallResultChange); // Remove old if exists
        overallSelect.addEventListener('change', handleOverallResultChange);

        // Initial call for winner method visibility and display string
        toggleWinnerMethodVisibility();
        generateAndSetMatchResultDisplay();
    };

    function handleOverallResultChange(e) {
        overallMatchResult = e.target.value;
        deriveWinningSideFromOverall();
        toggleWinnerMethodVisibility(); // This now calls generateAndSetMatchResultDisplay
        updateHiddenInputs();
    }
</script>
{% endblock %}
